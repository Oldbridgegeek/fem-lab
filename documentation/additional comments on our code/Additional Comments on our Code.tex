\documentclass[a4paper,12pt]{article}
\usepackage{amsmath}
\usepackage{bm}
\usepackage[mathscr]{euscript}
\begin{document}

\title{Additional Comments on our Code}

\author{Marcel DÃ¼rr \and Enes Witwit}

\section{Introduction}

In this document, we will recapitulate our code and provide further explanations on selected excerpts of our code

\section{Mesh}

We start of with our mesh generator 'mesh\_generate'. Our domain $\Omega = [0,1]^2$ will not be subject to change for this task, therefore our only input will be the mesh size $h$. The result will be two matrices, namely \textit{vertex\_matrix} and \textit{cell\_matrix}. \textit{vertex\_matrix} will store the coordinates of each vertex, while \textit{cell\_matrix} only stores the numbers of the four vertices of each cell.
\\
\textit{Example}: $h=0.5$

\[\mbox{\textit{vertex\_matrix}}=\begin{pmatrix} 0&0\\0.5&0\\1&0\\0&0.5\\0.5&0.5\\1&0.5\\0&1\\0.5&1\\1&1\\\end{pmatrix},\ \mbox{\textit{cell\_matrix}}=\begin{pmatrix} 1&2&4&5\\2&3&5&6\\4&5&7&8\\5&6&8&9\\
\end{pmatrix}\]

\section{Shape Functions}

An essential concept for finite element methods would be shape functions. We have to set up certain points, so called \textit{nodes} on a reference cell $\hat T = [0,1]^2$ such that our shape functions $p_i$ are uniquely defined by two properties: 
\begin{enumerate}
\item $p_i(x_j)=\delta_{ij}, \ x_j \mbox{node}$
\item $p_i$ is a polynomial on each edge.
\end{enumerate} 
 
A way to achieve this, is to choose the location of the nodes in the same way as our mesh. Afterwards, we choose appropriate base-polynomials. If we want polynomials of degree $k$ on the edges, the appropriate basis would be $\{x^iy^j, \ i,j=0...k\}$. Although the resulting polynomials are of order $2k$, they are only of order $k$ in each variable and therefore only of order $k$ on each edge. A mesh generated with mesh-size $\fraction{1}{k}$ will yield $k+1$ nodes on each edge; the interpolation is well-posed. \\
\textit{Remark}: The way we order our basis has to be consistent for the entire code, because we only store the coefficients when we want to store a polynomial. In particular, this means that one entry of the coefficient vector must refer to the same polynomial basis element, even for different orders of polynomials. Effectively, this means that the basis for a higher order polynomial can only add basis elements at the end of any lower order polynomial basis. \\

\textit{sf\_generate} follows this scheme closely. Since the shape functions only depend on the polynomial degree $k$ we want to have on the edges, our only input will be the integer $k$. The function will create the nodes using \textit{mesh\_generate} with mesh-size $\fraction{1}{k}$. Next, it will create a data-set, containing the coordinates and the value at these coordinates for each node. In total, we get $(k+1)^2:=n$ nodes, their values are computed using the Kronecker Delta. This will ensure, that property 1) holds true when interpolating over all these points. The interpolation is solved by 
\[\begin{pmatrix} 1 \ x_0 \ \cdots\ x_0^ky_0^k \\ \vdots \ \vdots \ \ddots \ \vdots \\ 1 \ x_{n} \ \cdots \ x_{n}^ky_{n}^k \end{pmatrix}
\begin{pmatrix} a_0 \\ \vdot \\ a_n \end{pmatrix}\]


\section{Weak Formulation}

In order to apply some of the results from the lecture, we need to derive the weak formulation of the given problem 
\begin{align}
\mbox{Find } u\in C^2(\Omega)\mbox{ :}-\Delta u+u &= \cos(\pi x)\cos(\pi y) &&\mbox{in } \Omega \\
\partial _n u &= 0 &&\mbox{on } \partial\Omega.
\end{align}
Multiplying with an arbitary $v\in C^2(\Omega)$ and integrating over $\Omega$ gives us
\[-\int _\Omega \Delta uv \,\mbox{d} \bm{x} + \int _\Omega uv \,\mbox{d} \bm{x} = \int _ \Omega fv\,\mbox{d} \bm{x}\]
where $f=\cos(\pi x)\cos(\pi y)$ and $\bm{x}=(x,y)$. Using Green's first formula and (2) we can obtain the weak formulation
\[\int _\Omega \nabla u\nabla v \,\mbox{d} \bm{x} + \int _\Omega uv \,\mbox{d} \bm{x} = \int _ \Omega fv\,\mbox{d} \bm{x}\]
From now on, we will denote the left hand side of the equation by $a(u,v)$ and the right hand side by $F(v)$. Thus, we obtain the weak formulation
\begin{equation}
\mbox{Find }u\in H^1(\Omega) \mbox{ :} \quad a(u,v)=F(v)\quad \forall v \in H^1(\Omega)
\end{equation}

\section{Existence and Uniqueness of a Solution}

We can already see, that our bilinear form $a(\cdotp ,\cdot)$ is the inner product associated with the norm on our function space $H^1(\Omega)$. We want to use the Riesz representation theorem to prove existence and uniqueness of a solution. In order to do so, it remains to show that our functional $F(\cdot)$ is linear and bounded. Linearity follows from the properties of integration. Using Hoelder's inequality, we show that
\begin{align*}
F(u)&=\|fu\|_{L^1(\Omega)}\\
	&\stackrel{\tiny\mbox{Hld.}}{\le} \|f\|_{L^2(\Omega)}\|u\|_{L^2(\Omega)}\\
	&\le \|1\|_{L^2(\Omega)}\ \big(\|u\|_{L^2(\Omega)}+\|u\|_{L^2(\Omega)}\big)\\
	&\le c\ \|u\|_{H^1(\Omega)}\mbox{,}
\end{align*}
where c depends on our domain $\Omega$. For our case, we have $\Omega=[0,1]^2$, in particular this means that $\Omega$ is bounded and our constant $c$ is finite. Therefore, $F(\cdot)$ is a bounded, linear functional and we can apply the Riesz representation theorem.

\section{Finding the Analytical Solution}

Now that we know that a unique solution exists, we want to actually compute it. We will use the ansatz $u=C\cos(\pi x)\cos(\pi y)$, with its gradient $\Delta u=2\pi^2 u$. Inserting in (1) gives us
\begin{equation}
-2C\pi^2 \cos(\pi x)\cos(\pi y) + C\cos(\pi x)\cos(\pi y)=\cos(\pi x)\cos(\pi y)
\end{equation}
\begin{align}
&\Rightarrow - 2C\pi^2 + C =1\\
&\Leftrightarrow C = \frac{1}{1-2\pi^2}
\end{align}
This leaves us with the solution $u=\frac{1}{1-2\pi^2}\cos(\pi x)\cos(\pi y)$.

\section{Integrals and Transformations}

The transformations we have to use for our FEM-code are very simple, since our mesh will be generated uniformly. Ultimately, we will only have to scale and displace our reference cell. We decided, that we will hard-code this property, since it will heavily simplifiy the computation of the local stiffness-matrices and the right-hand-side of the linear system, as we will see in brief.
\\ \\
Let $T$ be a cell of the mesh with vertices $v_1,v_2,v_3,v_4$, where $v_1$ is the vertex on the bottom left and h is the length of every edge. $\hat T = [0,1]^2$ shall be our reference cell. Then, our transformation $F$ will look like 
\[F \smash : \  \hat T \rightarrow T, \ \ \bm{\hat x}=\begin{pmatrix}\hat x \\ \hat y \end{pmatrix} \mapsto \begin{pmatrix}h \ 0 \\ 0 \ h\end{pmatrix} \begin{pmatrix}\hat x \\ \hat y \end{pmatrix} + v_1 := \begin{pmatrix}x\\y\end{pmatrix} := \bm{x}\]
We immediately can see, that the jacobian $J$ is given by
\begin{equation}
J(\bm{\hat x})=J=\begin{pmatrix}h \ 0\\0 \ h\end{pmatrix}\mbox{,}
\end{equation}
in particular, it is independet of $\bm{\hat x}$. Consequently, we also get
\begin{equation}
|\mbox{det}(J(\bm{\hat x}))|=|\mbox{det}(J)|=h^2\mbox{and} \ J^{-1}=h^{-1}\begin{pmatrix}1 \ 0 \\ 0 \ 1\end{pmatrix}
\end{equation}
Using the results from the lecture on the transformation of our bilinear form $a(\cdotp, \cdot)$ and using (7) and (8), we can compute the stiffness matrix in the following way
\[a^{(T)}_{ij} = \int_{\hat T}\nabla p_i \,\cdotp \nabla p_j\,\mbox{d}\bm{\hat x} + h^2\int_{\hat T}p_i p_j\,\mbox{d}\bm{\hat x}\mbox{,}\]
where $p_i$ and $p_j$ are our shape functions.\\ \\
\textit{Remark:} Note that the $\nabla$ in our formula refers to the gradient with respect to $\bm{\hat x}=\begin{pmatrix} \hat x \\ \hat y\end{pmatrix}$.
\textit{Remark:} Note that for affine transformations, the local stiffness matrices do not depend on the cell $T$, for which we want to compute it. Therefore, every local matrix looks the same and we only have to compute it once.
\\ \\
For the right-hand side, we have to look at the substitution formula for higher dimension integrals. But first of all, we need do split the intagral up. Let $\phi_i$ be a basis function of our domain $\Omega$, $\mathscr{T}_h$ our meshcells and $\mathscr{T}_i$ the mesh cells, on which $\phi_i \neq 0$. Then we get
\begin{align*}
\int_{\Omega}f(\bm{x})\phi_i(\bm{x})\ \mbox{d}\bm{x}&=\sum_{T\in\mathscr{T}_h} \int_Tf(\bm{x})\phi_i(\bm{x})\ \mbox{d}\bm{x} \\
													&=\sum_{T\in\mathscr{T}_i} \int_Tf(\bm{x})\phi_i(\bm{x})\ \mbox{d}\bm{x} \\
													&=\sum_{T\in\mathscr{T}_i} \int_Tf(\bm{x})p^{(T)}_{i^{(T)}}(\bm{x})\ \mbox{d}\bm{x} \\
													&=\sum_{T\in\mathscr{T}_i} \int_{\hat T}f(F^{(T)}(\bm{\hat x})\hat p_{i^{(T)}}(\bm{\hat x})|\mbox{det}(J)|\ \mbox{d}\bm{\hat x} \\
													&=h^2\sum_{T\in\mathscr{T}_i} \int_{\hat T}f(h\bm{\hat x}+v^{(T)}_1)\hat p_{i^{(T)}}(\bm{\hat x})\ \mbox{d}\bm{\hat x}						
\end{align*}

\end{document}
